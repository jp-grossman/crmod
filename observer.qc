//
// Observer.qc
//
// Contains code for handling observers.
//
// All code by J.P. Grossman unless otherwise commented.
//
// Fields used:
//
// .wait            - time to look for teleports when observing
// .trigger_field   - closest teleport entity; used when observing
// .t_width         - activation radius for closest teleport
// .dest            - stores destination for popping forward
// .dest1           - stores velocity for popping forward
// .movetarget      - player being watched in observer mode (world if none)
// .crmod_othertarget     - player to focus on during tourney cam // CRMOD
// .delay           - time to refresh head's up display for observing
// .speed           - z component of velocity from previous frame (for fly)
// .lip             - time to clear display when no target is in line of sight (walk/fly)
//

// function declarations
entity (entity e) observer_find_target;
entity (entity e) observer_find_camera;			// CRMOD
void () observer_set_camera_position;			// CRMOD
void () observer_set_chase_position;
void () observer_set_demo_position;
void (entity client) observer_disconnect_notify;
void () observer_heads_up;
void () SetNewParms2;
void () respawn;
void () PutClientInServer;
void () observer_get_target;
void () WaterMove;
void () CheckWaterJump;
void (entity player) match_remove_player;
void (entity player) match_disconnect_notify;

//
//  F I N D  T E L E P O R T
//
//  Find the closest teleport and remember it.  Called once every second.
//
void () observer_find_teleport =
{
    local entity e;
    local float d, mindist;
    local string temp;
    local vector vtemp;

    // find the closest teleport
    mindist = 99999999;
    e = self.trigger_field = find(world, classname, "trigger_teleport");
    while (e)
    {
        d = vlen(self.origin - (e.mins + e.maxs) * 0.5);
        if (d < mindist)
        {
            mindist = d;
            self.trigger_field = e;
        }
        e = find(e, classname, "trigger_teleport");
    }
    e = self.trigger_field;

    // compute an 'activation raius'
    if (e)
        self.t_width = utils_min3(e.size_x, e.size_y, e.size_z) * 0.7;
};

//
//  S P A W N  T F O G
//
void (vector pos) observer_spawn_tfog =
{
    msg_entity = self;
    WriteByte(MSG_ONE, SVC_TEMPENTITY);
    WriteByte(MSG_ONE, TE_TELEPORT);
    WriteCoord(MSG_ONE, pos_x);
    WriteCoord(MSG_ONE, pos_y);
    WriteCoord(MSG_ONE, pos_z);
};

//
//  C H E C K  T E L E P O R T
//
//  Check to see if on observer hit the closest teleport.
//
void () observer_check_teleport =
{
    local entity t;
    local vector d;

    t = self.trigger_field;
    if (!t)
        return;

    // Only check if the observer is not completely above/below the teleport
    if (self.absmin_z < t.absmax_z && self.absmax_z > t.absmin_z)
    {
        d = self.origin - (t.absmin + t.absmax) * 0.5;
        d_z = 0;
        if (vlen(d) < 24 + self.t_width)
        {
            // find the destination
            t = find(world, targetname, t.target);
            if (!t)
                return;

            // spawn a tfog flash for the observer only
            makevectors(t.mangle);
            observer_spawn_tfog(t.origin + 32 * v_forward);

            // move the observer
            setorigin(self, t.origin);
            self.angles = t.mangle;
            self.fixangle = 1;
            self.velocity = v_forward * 300;
            if (self.oflags & OBSERVER_WALK)
                self.flags = self.flags - (self.flags & FL_ONGROUND);
        }
    }
};

//
//  C L E A R  F L A G S
//
void () observer_clear_flags =
{
    self.oflags = self.oflags - self.oflags & (OBSERVER_WALK | OBSERVER_FLY | OBSERVER_CHASE | OBSERVER_DEMO | OBSERVER_CAMERA | OBSERVER_AUTO);
    self.crmod_othertarget = world;  // CRMOD
};

//
//  C H E C K  D E M O  E N D
//
//  If we're coming out of demo mode, we need to do a bit of cleaning up.
//  The reason for the model junk is that, for some reason, setting
//  the model to string_null (done in observer_demo_start) causes the
//  player to be unable to move.  The hack-fix is to set the model to
//  something real (eyes) which allows the player to move, and then
//  immediately assign string_null to self.model so that nobody sees the
//  player.  I don't know enough about quake to understand why it's
//  okay to assign string_null to self.model but not to call setmodel
//  with string_null; all I know is that this works.
//
void () observer_check_demo_end =
{
    if (self.oflags & OBSERVER_DEMO)
    {
        setmodel (self, "progs/eyes.mdl");
        self.model = string_null;
        msg_entity = self;
        WriteByte(MSG_ONE, SVC_SETVIEWPORT);
        WriteEntity(MSG_ONE, self);
    }
};

//
//  W A L K  S T A R T
//
void () observer_walk_start =
{
    observer_check_demo_end();
    observer_clear_flags();
    self.oflags = self.oflags | OBSERVER_WALK;
    self.finaldest_y = self.movetype = MOVETYPE_WALK;
    self.flags = self.flags - (self.flags & FL_ONGROUND);
    self.view_ofs = '0 0 22';
    if (self.style & ELOHIM_FOUND_BINDINGS)  // CRMOD - don't send sm0 if they don't have that alias
        stuffcmd(self, "sm0\n");		// CRMOD - smoothing off
    else
    	stuffcmd(self, "cl_nolerp 0\n");	// CRMOD - send the real thing instead
    stuffcmd(self, "v_centerspeed 500\n");
    sprint(self, "walk mode - help-walk for help\n");
    if (!(self.style & ELOHIM_HEADS_UP))
        sprint(self, "type 'headsup' for fullscreen display\n");
};

//
//  F L Y  S T A R T
//
void () observer_fly_start =
{
    observer_check_demo_end();
    observer_clear_flags();
    self.oflags = self.oflags | OBSERVER_FLY;
    self.finaldest_y = self.movetype = MOVETYPE_FLY;
    self.view_ofs = '0 0 22';
    self.flags = self.flags | FL_ONGROUND;
	self.waterlevel = 0;
    stuffcmd(self, "sm0\n");		// CRMOD - smoothing off
    stuffcmd(self, "v_centerspeed 500\n");
    sprint(self, "fly mode - help-fly for help\n");
    if (!(self.style & ELOHIM_HEADS_UP))
        sprint(self, "type 'headsup' for fullscreen display\n");
};


// CRMOD
// C A M E R A  S T A R T
//   by Paul Baker
//
//   Starts up Camera Mode
void () observer_camera_start =
{
	local entity camera;
    if (!self.movetarget)
    {
        // see if we can find a camera
        self.movetarget = observer_find_camera(world);
        if (!self.movetarget)
        {
            sprint(self, "no cameras found\n");
            observer_walk_start();
            return;
        }
        self.delay = 0;
    }
    else if (self.movetarget.classname != "elohim_camera")
    {
    	// see if we can find a camera
        self.movetarget = observer_find_camera(world);
        if (!self.movetarget)
        {
            sprint(self, "no cameras found\n");
            observer_walk_start();
            return;
        }
        self.delay = 0;
    }
   
    observer_check_demo_end();
    observer_clear_flags();
    self.oflags = self.oflags | OBSERVER_CAMERA;
    self.finaldest_y = self.movetype = MOVETYPE_NONE;
    self.view_ofs = '0 0 0';
    camera = self.movetarget;
	setorigin(self, camera.origin);
	local vector angle;
	if (camera.movetarget != world)
		angle = angles_bestaim(camera.origin, camera.movetarget.origin);
	else
		angle = camera.angles;
	angles_fixangle(angle);
    observer_set_camera_position();
    stuffcmd(self, "v_centerspeed 0\n");
    sprint(self, "camera mode - help-camera for help\n");
    if (self.oflags & OBSERVER_GO_AUTO)				// CRMOD
    {												// CRMOD
    	sprint(self,"Automatic Cameras Enabled.\n");	// CRMOD
    	self.oflags = self.oflags - OBSERVER_GO_AUTO;	// CRMOD
    	self.oflags = self.oflags | OBSERVER_AUTO;	// CRMOD
    }												// CRMOD
    else																// CRMOD
    	sprint(self,"type 'autocam' for automatic camera switching\n");	// CRMOD
    
    if (!(self.style & ELOHIM_HEADS_UP))
        sprint(self, "type 'headsup' for fullscreen display\n");
	sprint(self, "use proquake to eliminate choppines\n");
};

//
//  C H A S E  S T A R T
//
void () observer_chase_start =
{
    if (!self.movetarget || self.movetarget.classname != "player")
    {
        // see if we can find a target to chase
        self.movetarget = observer_find_target(world);
        if (!self.movetarget)
        {
            sprint(self, "no chase target found\n");
            observer_walk_start();
            return;
        }
        self.delay = 0;
    }
    observer_check_demo_end();
    observer_clear_flags();
    self.oflags = self.oflags | OBSERVER_CHASE;
    self.finaldest_y = self.movetype = MOVETYPE_FLY;
    self.view_ofs = '0 0 0';
    observer_set_chase_position();
    stuffcmd(self, "v_centerspeed 0\n");
    sprint(self, "chase mode - help-chase for help\n");

	// CRMOD - auto, tourney
    if (self.oflags & OBSERVER_GO_AUTO)
    {
    	sprint(self,"Automatic Chasecam Enabled.\n");
    	self.oflags = self.oflags - OBSERVER_GO_AUTO;
    	self.oflags = self.oflags | OBSERVER_AUTO;
    }
    else
    	sprint(self,"type 'autochase' for automatic chase switching\n");
    if (self.oflags & OBSERVER_TOURNEY)
    	sprint(self,"Tournament Mode Enabled.\n");
	// END_CRMOD
    
    if (!(self.style & ELOHIM_HEADS_UP))
        sprint(self, "type 'headsup' for fullscreen display\n");
	sprint(self, "use proquake to eliminate choppines\n");
};

//
//  D E M O  S T A R T
//
//  Not only do we have to set the viewport to the chase target for demo
//  mode to work, but we also have to call setmodel on self.. for some
//  reason the client will draw a player model where 'self' is when the
//  viewport is changed!  The effect is that you seem to be standing
//  inside yourself - even though no-one else can see you.  The fix is
//  the setmodel call.. but this can cause a problem later on when we
//  want to change back to walk mode (see comment before
//  observer_check_demo_end, above).
//
void () observer_demo_start =
{
    if (!self.movetarget || self.movetarget.classname != "player")
    {
        // see if we can find a target to chase
        self.movetarget = observer_find_target(world);
        if (!self.movetarget)
        {
            sprint(self, "no chase target found\n");
            observer_walk_start();
            return;
        }
        self.delay = 0;
    }
    observer_clear_flags();
    self.oflags = self.oflags | OBSERVER_DEMO;
    self.finaldest_y = self.movetype = MOVETYPE_FLY;
    self.view_ofs = '0 0 22';
    msg_entity = self;
    WriteByte(MSG_ONE, SVC_SETVIEWPORT);
    WriteEntity(MSG_ONE, self.movetarget);
    setmodel(self, string_null);
    observer_set_demo_position();
    stuffcmd(self, "v_centerspeed 0\n");
    sprint(self, "eyecam mode - help-chase for help\n");
    if (!(self.style & ELOHIM_HEADS_UP))
        sprint(self, "type 'headsup' for fullscreen display\n");
	sprint(self, "use proquake to eliminate choppines\n");

	self.nextthink = -1;
    self.think = SUB_Null;
};

//
//  R E S E N D  N A M E
//
//  In case it didn't make it through the first time
//
void () observer_resend_name = 
{
	local entity oself;

	oself = self;
	self = self.owner;
	if (self.style & ELOHIM_OBSERVER)
		name_broadcast(self.netname);
	self = oself;
	remove(self);
};

//
//  S T A R T
//
//  Enter observer mode.
//
void () observer_start =
{
    local float go_auto;
    
    self.style = self.style | ELOHIM_OBSERVER;

    // Notify the match module that this player has become an observer
	// Must do this before calling chase_start etc.. since we need to
	// remove the player from the list before messing with next_player
	//
	// Must also come before self.items is reset to avoid messing up the RL count
    if (elohim_playmode & ELOHIM_MATCH_MODE)
	{
		match_remove_player(self);   // This needs to go first
        match_disconnect_notify(self);
	}
	else
		elohim_remove_player_from_list();

	utils_make_scheduled_event(observer_resend_name, 0.5);

	self.next_player = world;

	// If the player is dead, then call respawn to reset a bunch of stuff and
	// give him a new position.
    if (self.deadflag != DEAD_NO)
    {
        if (self.deadflag >= DEAD_DEAD)
            respawn();
		else
		{
			// Can't go observer while dying
			self.style = self.style - ELOHIM_OBSERVER;
			return; 
		}
    }

//	if ((self.style & ELOHIM_ADMINISTRATOR) && !self.crmod_hack_count)
//		self.cl[CL_PRIVILEGED] = TRUE;

    self.crmod_chase_score = ELOHIM_NEGINF;  // CRMOD make sure they don't have some high rating that can't be beat by the other players

    self.takedamage = DAMAGE_NO;
    self.solid = SOLID_NOT;

    // get rid of powerups
    self.radsuit_finished = 0;
    self.invisible_finished = 0;
    self.invincible_finished = 0;
    self.super_damage_finished = 0;
    self.rad_time = 0;
    self.invisible_time = 0;
    self.invincible_time = 0;
    self.super_time = 0;
    self.effects = 0;

    // status bar stuff
    self.health = 666;
    self.items = 0;
    self.armorvalue = 0;
    self.ammo_shells = 0;
    self.ammo_nails = 0;
    self.ammo_rockets = 0;
    self.ammo_cells = 0;
    self.currentammo = 0;
    self.frags = -99;
    self.show_hostile = 0;

    // model and view offset
    self.model = string_null;
    self.weaponmodel = string_null;
    setsize (self, VEC_HULL_MIN, VEC_HULL_MAX);
    self.view_ofs = '0 0 22';
    self.nextthink = -1;    // thinking is used to animate client models
    self.think = SUB_Null;

    // teleport stuff
    observer_find_teleport();
	self.wait = time + 2;

    // update display immediately
    self.delay = 0;

	// reset display hold time
	self.lip = 0;

    stuffcmd(self, "color 0\n");
    
    if (self.oflags & OBSERVER_FLY)
        observer_fly_start();
    else if (self.oflags & OBSERVER_CHASE)
	{
		if (self.oflags & OBSERVER_AUTO)
			self.oflags = self.oflags | OBSERVER_GO_AUTO;
        observer_chase_start();
	}
    else if (self.oflags & OBSERVER_DEMO)
	{
		// This is necessary to prevent the other player's model from being 
		// drawn.  Don't fucking as me why!!!
		self.nextthink = time + 0.1;
		self.think = observer_demo_start;
	}
    else if (self.oflags & OBSERVER_CAMERA)
	{
		if (self.oflags & OBSERVER_AUTO)
			self.oflags = self.oflags | OBSERVER_GO_AUTO;
    	observer_camera_start();
	}
    else
        observer_walk_start();

    if (self.style & ELOHIM_HEADS_UP)
        stuffcmd(self, "viewsize 120\n");

    // Check to see if anyone was observing this client
    observer_disconnect_notify(self);
};

//
//  O B S E R V E R  E N D
//
//  Return to normal player mode.
//
void () observer_end =
{
	if (!(self.style & ELOHIM_OBSERVER))
		return;

	self.style = self.style - ELOHIM_OBSERVER;
    self.frags = 0;

//	if (!(elohim_playmode & ELOHIM_PRACTICE_MODE))
//		self.cl[CL_PRIVILEGED] = FALSE;

    observer_check_demo_end();
    stuffcmd(self, "sm0\n");		// CRMOD - smoothing off
    stuffcmd(self, "v_centerspeed 500\n");
    if (self.style & ELOHIM_HEADS_UP)
	    stuffcmd(self, "viewsize 100\n");
    if (!(elohim_playmode & ELOHIM_MATCH_MODE))
	{
        centerprint(self, "Observer mode off");
		elohim_put_player_in_list();
	}

	// This is to prevent a condition where one player is another player's
	// movetarget, which can confuse the auto module.
	self.movetarget = world;	

    stats_reset_player();
    SetNewParms2();
    PutClientInServer();
};

// CRMOD
//  F I N D  C A M E R A
//    by Paul Baker
//
//  Returns the next camera after the given entity.
//
entity (entity e) observer_find_camera =
{
    local entity targ;

    targ = find(e, classname, "elohim_camera");
    if (targ == world)
    	targ = find(targ, classname, "elohim_camera");
    return targ;
};

// CRMOD
//  N E X T  C A M E R A
//    by Paul Baker
//
//  Get next camera to watch from.
//
void () observer_next_camera =
{
	local entity camera;
	local vector angle;
	self.movetarget = camera = observer_find_camera(self.movetarget);
	setorigin(self, camera.origin);
	if (camera.movetarget != world)
		angle = angles_bestaim(camera.origin, camera.movetarget.origin);
	else
		angle = camera.angles;
	angles_fixangle(angle);
	self.delay = 0;
};

// CRMOD
//  P R E V  C A M E R A
//    by Paul Baker
//    
//  Get previous camera to watch from.
//
void () observer_prev_camera =
{
	local entity e, curr, camera;
	local vector angle;
	
	curr = self.movetarget;
	e = observer_find_camera(curr);
	
	while (e != curr)
	{
		self.movetarget = e;
		e = observer_find_camera(e);
	}
	camera = self.movetarget;
	setorigin(self, camera.origin);
	if (camera.movetarget != world)
		angle = angles_bestaim(camera.origin, camera.movetarget.origin);
	else
		angle = camera.angles;
	angles_fixangle(angle);
	self.delay = 0;
};

//
//  F I N D  T A R G E T
//
//  Returns the next watch target after the given entity.
//
entity (entity e) observer_find_target =
{
    local entity targ;

    if ((e.classname != "player") || (e.style & ELOHIM_OBSERVER) || !(e.style & ELOHIM_CONNECTED))
        e = world;
    targ = find(e, classname, "player");
    while (targ != e && (!targ || (targ.style & ELOHIM_OBSERVER) || !(targ.style & ELOHIM_CONNECTED)))
        targ = find(targ, classname, "player");
    return targ;
};

//
//  N E X T  T A R G E T
//
//  Get the next target to watch.
//
void () observer_next_target =
{
    self.movetarget = observer_find_target(self.movetarget);

    // Force an immediate update of the heads-up display
    self.delay = 0;
    
    if ((self.oflags & OBSERVER_DEMO) && (self.movetarget != world))
	{
		msg_entity = self;
		WriteByte(MSG_ONE, SVC_SETVIEWPORT);
		WriteEntity(MSG_ONE, self.movetarget);
		observer_set_demo_position();
	}
};

//
//  P R E V  T A R G E T
//
//  Get the previous target to watch.
//
void () observer_prev_target =
{
    local entity e, curr;

    if (!self.movetarget)
    {
        observer_next_target();
        return;
    }

    curr = self.movetarget;
    if (curr.style & ELOHIM_OBSERVER || curr.classname != "player" ||
        !(curr.style & ELOHIM_CONNECTED))
    {
        self.movetarget = curr = observer_find_target(curr);
    }
    e = observer_find_target(curr);
    while (e != curr)
    {
        self.movetarget = e;
        e = observer_find_target(e);
    }

    // Force an immediate update of the heads-up display
    self.delay = 0;

    if ((self.oflags & OBSERVER_DEMO) && (self.movetarget != world))
	{
		msg_entity = self;
		WriteByte(MSG_ONE, SVC_SETVIEWPORT);
		WriteEntity(MSG_ONE, self.movetarget);
		observer_set_demo_position();
	}
};

//
//  L O O K  F O R  T A R G E T
//
//  Helper function for observer_get_target; looks in a single direction.
//  Returns TRUE if a target is found; FLASE otherwise.
//
float (vector from) observer_look_for_target = 
{
	traceline(from, from + v_forward * 1200, FALSE, self);
	if (trace_fraction < 1.0)
	{
		if (trace_ent.classname == "player" && (trace_ent.style & ELOHIM_CONNECTED))
		{
			if (self.movetarget != trace_ent)
			{
				self.movetarget = trace_ent;
				self.delay = 0;
				self.lip = time + 1;
			}
			return TRUE;
		}
	}
	return FALSE;
};

//
//  G E T  T A R G E T
//
//  Looks for a client in the line of sight.
//
void () observer_get_target =
{
	local vector from;
	local vector angle;

	// first check to see if old one is still visible
	if (self.movetarget)
	{
		local float temp;
		angle = vectoangles(self.movetarget.origin - self.origin);
		temp = angle_y - self.v_angle_y;
		if (temp > 180)
			temp = temp - 360;
		temp = fabs(temp);
		if (temp < 15)
		{
			// they're still there
			self.lip = time + 1;
			return;
		}
	}

	angle = self.v_angle;
	from = self.origin + '0 0 22';

    makevectors(angle);
	if (observer_look_for_target(from))
		return;
	angle_y = angle_y + 5;
    makevectors(angle);
	if (observer_look_for_target(from))
		return;
	angle_y = angle_y - 10;
    makevectors(angle);
	if (observer_look_for_target(from))
		return;

	// didn't find anyone
	if (self.movetarget != world && self.lip < time)
	{
		self.movetarget = world;
		self.delay = 0;
	}
};

//
//  D I S C O N N E C T  N O T I F Y
//
//  Called when a client disconnects or becomes an observer.  Used to
//  update the watch target for any observers that were watching this client.
//
void (entity client) observer_disconnect_notify =
{
    local entity e, oself;
	
    
    e = find(world, classname, "player");
    while (e)
    {
        if ((e.style & ELOHIM_OBSERVER) && (e.movetarget == client))
        {
            oself = self;
            self = e;
            observer_next_target();
            if (!self.movetarget)
			{
				if (self.oflags & (OBSERVER_CHASE | OBSERVER_DEMO))
				{
					sprint(self, "No more chase targets\n");
					observer_walk_start();
				}
				else if (self.oflags & (OBSERVER_CAMERA))
					observer_next_camera();
			}
            self = oself;
        }
        e = find(e, classname, "player");
    }
    
    // CRMOD so cameras don't follow either
    if (self == crmod_best_chase_target)
    	crmod_best_chase_target = world;
	if (self == crmod_current_chase_target)
		crmod_current_chase_target = crmod_best_chase_target;
	if (self == crmod_best_camera)
		crmod_best_camera = find(world, classname, "elohim_camera");
	if (self == crmod_current_camera)
		crmod_current_camera = crmod_best_camera;

    e = find(world, classname, "elohim_camera");
    while (e)
    {
    	if (e.movetarget == client)
    	{
    		oself = self;
    		self = e;
			self.movetarget = world;
    		auto_camera_think();
    		self = oself;
    	}
    	e = find(e, classname, "elohim_camera");
    }
    // CRMOD END
};

//
//  F I N D  E N E M Y
//    by Paul Baker
//
//  Corrected and optimized by J.P.
//
//  Called by observer_set_chase_position for use in tourneycam mode
//
void () observer_find_enemy =
{
	local entity potential;

	if (self.crmod_did_damage + 1 > time) // did he hurt someone?
		self.crmod_othertarget = self.movetarget.crmod_inflicted;
	else if ((!self.crmod_othertarget) || (self.health > self.movetarget.health)) // did he get hurt?
	{
		if (self.movetarget.dmg_inflictor.classname == "missile" || self.movetarget.dmg_inflictor.classname == "grenade")
			self.crmod_othertarget = self.movetarget.dmg_inflictor.owner;
		else if (self.movetarget.dmg_inflictor.classname == "player")
			self.crmod_othertarget = self.movetarget.dmg_inflictor;
	}

	// Sanity check
	if (self.crmod_othertarget)
	{
		if ((self.crmod_othertarget.style & ELOHIM_OBSERVER) || !(self.crmod_othertarget.style & ELOHIM_CONNECTED) || (self.crmod_othertarget == self.movetarget))
			self.crmod_othertarget = world;
		else if ((self.crmod_othertarget.team == self.movetarget.team) && teamplay)
			self.crmod_othertarget = world;
		else if (!utils_new_visible(self.movetarget, self.crmod_othertarget))
			self.crmod_othertarget = world;
		else if (self.crmod_othertarget.deadflag != DEAD_NO)//Sputnik: deadcam shake
			self.crmod_othertarget = world;
	}	

	// If no target, then look for a good one (check next player in list)
	if (!self.crmod_othertarget)
	{
		if (!self.next_player)
			self.next_player = elohim_sentinel.next_player;
		if (self.next_player == self.movetarget)
			self.next_player = self.next_player.next_player;
		potential = self.next_player;
		if (potential)
		{
			if (((potential.team != self.movetarget.team) || !teamplay) && (potential.deadflag == DEAD_NO))//Sputnik: deadcam shake
			{
				if (utils_new_visible(self.movetarget, potential))
					self.crmod_othertarget = potential;
			}
			self.next_player = potential.next_player;
		}
	}
};

//
//  S E T  C H A S E  P O S I T I O N
//
//  Called every frame for observers in chase mode.  Used to position
//  the observer behind the player being chased.
//
//  Chase cameras are tricky business - they are notoriously choppy.
//  This choppines is due to two problems:
//
//  1.  The network protocol quantizes angles into 256 discreet values.
//      The client, on the other hand, can set the angle (through user
//      input) much more precisely.  Hence, the chase target's view
//      angle is constantly being rounded off.
//
//  2.  The client side doesn't use the exact positions sent by the server
//
//  To address problem 1, we quantize the angles of the player being chased
//  *before* using them to calculate the new position.  This ensures that
//  the player being watched will stay in the center of the screen and will
//  not jitter back and forth due to angle roundoff.
//
//  To address problem 2, the client should enter "cl_nolerp 1" in their
//  console (the "smooth" alias does this automatically);
//
void () observer_set_chase_position =
{
    local vector pos;
    local vector desired_angle;	// CRMOD
    local vector angle;
    
    if (self.oflags & OBSERVER_AUTO)
	{
		// JP - added this because now this can be called from observer_set_camera_position
		if (self.oflags & OBSERVER_CHASE)
		{
			if (time > self.crmod_cam_delay)
			{
				if (crmod_current_chase_target != world && self.movetarget != crmod_current_chase_target)
				{
					self.movetarget = crmod_current_chase_target;
					self.delay = 0;
				}
			}
		}
	}

	// CRMOD - Setting angle equal to v_angle tricks the placement code below into
	// CRMOD - thinking that the direction you are looking is what the chase target
	// CRMOD - is lookin in.  This way freelook still keeps the player in view.

    if (self.button0)	// freelook
	{           
    	angle = self.v_angle;
		self.crmod_oldangle = self.v_angle;
	}
    else
    {
    	// CRMOD - tourney cam
       	if (self.oflags & OBSERVER_TOURNEY)
    	{
    		observer_find_enemy();
    		if (self.crmod_othertarget)
    		   	desired_angle = angles_bestaim(self.movetarget.origin, self.crmod_othertarget.origin);
    		else
    			desired_angle = self.movetarget.v_angle;
    	}
    	else
    		desired_angle = self.movetarget.v_angle;

		angle_x = self.crmod_oldangle_x * (1 - CRMOD_ANGLE_SMOOTHING) + desired_angle_x * CRMOD_ANGLE_SMOOTHING;
		angle_y = angles_pick_angle(self.crmod_oldangle_y, desired_angle_y, CRMOD_ANGLE_SMOOTHING);
		angle_z = 0;
	}

	// Quantize the player's angle so that the angle we use here will
	// be the same as the one used by the client (after the angle has been
	// garbled by the network protocol)
	//
	if (!self.button0)
	{
		angle_x = 360.0 / 256.0 * rint(angle_x * 256.0 / 360.0);
		angle_y = 360.0 / 256.0 * rint(angle_y * 256.0 / 360.0);
	}

    // The "ideal" position is 100 units behind and 40 units above the
    // chase target.  To deal with walls and ceilings, we first trace a
    // line 50 units up and then move 80% of the way along the
    // part of the line that was traced.  We then trace a line 120 units 
	// backwards and move 83% of the way along the part that was traced.
    //    
    makevectors(angle);
    pos = self.movetarget.origin;
    traceline(pos, pos + 50 * v_up, TRUE, self.movetarget);		
    pos = pos + (trace_fraction * 40) * v_up;					
    traceline(pos, pos - 120 * v_forward, TRUE, self.movetarget);
    pos = pos - (trace_fraction * 100) * v_forward;				
    setorigin(self, pos);

    if (self.button0)
        return;  // freelook; don't set the viewing angle

    angles_fixangle(angle);
};

//
//  S E T  D E M O  P O S I T I O N
//
//  Similar to, but simpler than, observer_set_chase_position.  We need
//  to set the view angles.  The view position is set semi-automatically,
//  but quake gets confused if the observer's entity is in a very different
//  location, so to keep it happy we move the observer's entity to the
//  chasetargets location.
//
void () observer_set_demo_position =
{
    setorigin(self, self.movetarget.origin);

    if (self.button0)
        return;  // freelook; don't set the viewing angle

    self.v_angle = self.angles = self.movetarget.v_angle;	// CRMOD added v_angle
    self.fixangle = TRUE;
};

// CRMOD
// S E T  C A M E R A  P O S I T I O N
//   by Paul Baker
//
//   Camera movement
//
void () observer_set_camera_position =
{	
	local entity camera;
	local vector angle;
	local entity player;
	local float seeable;
	
	camera = self.movetarget;

	if (self.oflags & OBSERVER_AUTO)
	{
		if (time > self.crmod_cam_delay)
		{
			if (crmod_current_camera != world && self.movetarget != crmod_current_camera)
			{
				camera = self.movetarget = crmod_current_camera;
				self.delay = 0;
				if (crmod_current_camera.classname == "elohim_camera")
				{
					local vector angle;
					setorigin(self, crmod_best_camera.origin);
					if (camera.movetarget)
					{
						angle = angles_bestaim(camera.origin, camera.movetarget.origin);
					}
					else
					{
						angle = camera.angles;
					}
					angles_fixangle(angle);
				}
			}
		}
	}
	else if (camera.classname == "elohim_camera") // in case the movetarget is a debug target
	{
		if ((time > self.crmod_cam_delay) && (time > camera.crmod_cam_delay))
			camera.movetarget = world;
		else if (camera.movetarget) 
		{
			if (!utils_visible(camera, camera.movetarget))
				camera.movetarget = world;
		}
		if (!camera.movetarget) 
		{
			camera.movetarget = elohim_sentinel;
			player = elohim_sentinel.next_player;
			while (player) 
			{
				if (utils_visible(camera, player)) 
				{
					if (player.crmod_chase_score > camera.movetarget.crmod_chase_score)
						camera.movetarget = player;
				}
				player = player.next_player;
			}
			if (camera.movetarget == elohim_sentinel)
				camera.movetarget = world;
			else
				self.crmod_cam_delay = time + 4;
		}
	}
	
	if (camera.classname == "player")
	{
		observer_set_chase_position();	// JP - added this
		return;
	}

	if (self.button0) // freelook
		return;

	/*	Sputnik changed -- see below
	if (camera.movetarget)
		angle = angles_bestaim(camera.origin, camera.movetarget.origin);
	else
		angle = camera.angles;
	*/

	// Sputnik -start
	if (camera.movetarget)
	{
		angle = angles_bestaim (camera.origin, camera.movetarget.origin);
		seeable = utils_new_visible (camera, camera.movetarget);
		if (seeable)
		{
			self.crmod_cam_delay = time + 4;// reset this once they are visible.
		}
	}
	else
	{
		if (self.crmod_cam_delay > time)	// aim where they were last at
			angle = self.crmod_oldangle;
		else
			angle = camera.angles;			// long enough reset back

	}
	// Sputnik -end

	angle_x = self.crmod_oldangle_x * (1 - CRMOD_ANGLE_SMOOTHING) + angle_x * CRMOD_ANGLE_SMOOTHING;
	angle_y = angles_pick_angle(self.crmod_oldangle_y, angle_y, CRMOD_ANGLE_SMOOTHING);
	angle_z = 0;
	angles_fixangle(angle);
};
	
//
//  H E L P
//
void () observer_help =
{
    sprint(self, "Observer commands:\n");
    sprint(self, " help-walk - help for walk mode\n");
    sprint(self, " help-fly  - help for fly mode\n");
    sprint(self, " help-chase- help for chase/demo mode\n");
    sprint(self, " help-camera - help for camera mode\n");
    sprint(self, " ready     - exit observer mode\n");
    sprint(self, " walk/flyme    > choose mode\n");
    sprint(self, " chase/eyecam  > choose mode \n");
    sprint(self, " autochase - automatic chasecam mode\n");
    sprint(self, " camera    - camera mode\n");
    sprint(self, " autocam   - automatic camera mode\n");
    sprint(self, " headsup   - toggle heads up display\n");
	sprint(self, " tourney   - toggle tournament chase\n");
	sprint(self, " commentary - toggle commentary\n");
};

//
//  W A L K  H E L P
//
void () observer_walk_help =
{
    sprint(self, "Walk mode controls:\n");
    sprint(self, " jump      - jump\n");
	sprint(self, " attack    - fly (through walls)\n");
    sprint(self, "help-observer - observer mode help\n");
};

//
//  F L Y  H E L P
//
void () observer_fly_help =
{
    sprint(self, "Fly mode controls:\n");
    sprint(self, " jump   - move up\n");
	sprint(self, " attack - fly through walls\n");
    sprint(self, "help-observer - observer mode help\n");
};

//
//  C H A S E  H E L P
//
void () observer_chase_help =
{
    sprint(self, "Chase/eyecam mode controls:\n");
    sprint(self, " attack    - freelook\n");
	sprint(self, " jump      - select next player\n");
	sprint(self, " attack + jump - previous player\n");
	sprint(self, " smooth    - toggle camera smoothing\n");
	sprint(self, " autochase - automatic chase mode\n");
	sprint(self, "             (chase mode only)\n");
	sprint(self, " tourney   - toggle tourneycam\n");
	sprint(self, "             (chase mode only)\n");
    sprint(self, "help-observer - observer mode help\n");
};

// CRMOD
//  C A M E R A  H E L P
//    by Paul Baker
void () observer_camera_help =
{
	sprint(self, "Camera mode controls:\n");
    sprint(self, " attack    - freelook\n");
	sprint(self, " jump      - select next camera\n");
	sprint(self, " attack + jump - previous camera\n");
	sprint(self, " smooth    - toggle camera smoothing\n");
	sprint(self, " autocam   - automatic camera mode\n");
	sprint(self, "help-observer - observer mode help\n");
};

//
//  C A N C E L  L E A V E
//
//  *Don't* leave the match.
//
void () observer_cancel_leave =
{
    local entity oself;

    if (self.owner.style & ELOHIM_CONFIRM_LEAVE)
    {
        self.owner.style = self.owner.style - ELOHIM_CONFIRM_LEAVE;
        sprint(self.owner, "Cancelled\n");
    }
    remove (self);
};

//
//  C O N F I R M
//
//  If someone enters the 'observer' impulse during a match, ask
//  them if they are sure they want to leave the match.
//
void () observer_confirm =
{
    if (self.style & ELOHIM_CONFIRM_LEAVE)
        return;

    sprint(self, "Leave match?  Type yes to confirm.\n");
    self.style = self.style | ELOHIM_CONFIRM_LEAVE;
    utils_make_scheduled_event(observer_cancel_leave, 5);
};

//
//  C O N F I R M  L E A V E  R E S P O N S E
//
//  They entered yes or know in response to the above prompt.
//
void (float response) observer_confirm_leave_response =
{
    self.style = self.style - ELOHIM_CONFIRM_LEAVE;
    if (response)
        observer_start();
    else
        sprint(self, "Cancelled\n");
};

//
//  I M P U L S E
//
//  Called from elohim_impulse in elohim.qc to handle observer impulses.
//
void () observer_impulse =
{
	if (elohim_state & ELOHIM_TAKING_AUTOSS)
		return;

    if (self.style & ELOHIM_OBSERVER)
    {
        if (self.impulse == 141)
		{
			self.oflags = self.oflags - (self.oflags & OBSERVER_QUAKETV);	//Sputnik, the player specifically chose this mode, placing here instead of observer_clear_flags.
            observer_walk_start();
		}
        else if (self.impulse == 142)
		{
			self.oflags = self.oflags - (self.oflags & OBSERVER_QUAKETV);	//Sputnik
            observer_fly_start();
		}
        else if (self.impulse == 143)
		{
			self.oflags = self.oflags - (self.oflags & OBSERVER_QUAKETV);	//Sputnik
            observer_chase_start();
		}
		else if (self.impulse == 147)
			utils_toggle_oflag(OBSERVER_COMMENTARY, "Running commentary");
        else if (self.impulse == 148)
            observer_heads_up();
        else if (self.impulse == 149)
            observer_demo_start();
        else if (self.impulse == 150)						
        	stuffcmd(self,"smooth\n"); 
        else if (self.impulse == 151)						
			utils_toggle_oflag(OBSERVER_TOURNEY, "Tournament chasecam mode");
		else if (self.impulse == 153)
			observer_camera_start();
		else if (self.impulse == 154)
			auto_camera_start();
		else if (self.impulse == 155)
		{
			self.oflags = self.oflags - (self.oflags & OBSERVER_QUAKETV);	//Sputnik
			auto_chase_start();
		}
    }
    else
    {                                                                              // CRMOD more commands to go observer
        if ((self.impulse >= 140 && self.impulse <= 143) || self.impulse == 149 || (self.impulse >= 153 && self.impulse <= 155))
        {
			if (self.impulse != 140)
			{
				observer_clear_flags();
				if (self.impulse == 141)
					self.oflags = self.oflags | OBSERVER_WALK;
				else if (self.impulse == 142)
					self.oflags = self.oflags | OBSERVER_FLY;
				else if (self.impulse == 143)
					self.oflags = self.oflags | OBSERVER_CHASE;
				else if (self.impulse == 149)
					self.oflags = self.oflags | OBSERVER_DEMO;
				// CRMOD more commands to go observer
				else if (self.impulse == 155)
					self.oflags = self.oflags | OBSERVER_CHASE | OBSERVER_GO_AUTO;
				else if (self.impulse == 153)
					self.oflags = self.oflags | OBSERVER_CAMERA;
				else if (self.impulse == 154)
					self.oflags = self.oflags | OBSERVER_CAMERA | OBSERVER_GO_AUTO;
				// CRMOD END
			}
			
            if (elohim_state & ELOHIM_MATCH_STARTED)
                observer_confirm();
            else
                observer_start();
        }
        else if (self.impulse >= 147 && self.impulse != 156)
            sprint(self, "You must be an observer first\n");
    }

    if (self.impulse == 144)
        observer_walk_help();
    else if (self.impulse == 145)
        observer_fly_help();
    else if (self.impulse == 146)
        observer_chase_help();
    else if (self.impulse == 156)
    	observer_camera_help();
};

//
//  J U M P
//
//  Modified version of PlayerJump in Client.qc
//  Fast movement in water/slime/lava; no sounds.
//
//  jump is TRUE if 'jump' was just pressed, FALSE if it is being
//  held down.
//
void (float jump) observer_jump =
{
	if (self.flags & FL_WATERJUMP)
		return;

    if (self.waterlevel >= 2)
	{
        if (self.waterlevel == 3)
            self.velocity_z = 320;
        else
            self.velocity_z = 100;
		return;
	}

    if (!(self.flags & FL_ONGROUND) || !jump)
		return;

	self.flags = self.flags - FL_ONGROUND;	// don't stairwalk
    self.velocity_z = 270;
};

//
//  C H E C K  S I Z E
//
//  If an observer gets caught in a door/platform etc, their size can
//  be set to zero.  This routine is called once every second to make
//  sure that this doesn't last.
//
void () observer_check_size =
{
    if (self.maxs_x < 16 || self.maxs_y < 16)
        setsize (self, VEC_HULL_MIN, VEC_HULL_MAX);
};

//
//  U P D A T E  S T A T U S  B A R
//
//  Copy the chasetarget's status into the observer's status bar.
//
void () observer_update_status_bar =
{
    local entity player;

	if (self.movetarget.classname == "elohim_camera")
		player = self.movetarget.movetarget;
	else
		player = self.movetarget;

    if (!player)
    {
		if (self.health == 666)
			return;

        self.health = 666;
        self.items = 0;
        self.armorvalue = 0;
        self.ammo_shells = 0;
        self.ammo_nails = 0;
        self.ammo_rockets = 0;
        self.ammo_cells = 0;
        self.currentammo = 0;
        self.show_hostile = 0;
        self.weapon = 0;
	    self.weaponmodel = string_null;
		return;
    }

    self.items = player.items;
    self.ammo_shells = player.ammo_shells;
    self.ammo_nails = player.ammo_nails;
    self.ammo_rockets = player.ammo_rockets;
    self.ammo_cells = player.ammo_cells;
    self.currentammo = player.currentammo;
    self.show_hostile = player.show_hostile;
    self.weapon = player.weapon;
	if (self.oflags & OBSERVER_DEMO)
	{
		self.weaponmodel = player.weaponmodel;
		self.weaponframe = player.weaponframe;
		if ((self.armorvalue != player.armorvalue) ||
			(self.health > player.health + 3) ||
			(self.health < player.health) ||
			(self.items < player.items))
			stuffcmd(self, "bf\n");
	}
	else
		self.weaponmodel = string_null;
    self.health = player.health;
    self.armorvalue = player.armorvalue;
	if (self.health <= 0)
		self.health = 1000;
};

//
//  S E T  O R I G I N
//
//  Try to put the observer somewhere around spot.  Return TRUE if successful,
//  FALSE otherwise.
//
float (vector spot) observer_set_origin = 
{
	local float d1, d2;

	// x
	traceline(spot, spot + '32 0 0', TRUE, world);
	d1 = 32 * trace_fraction;
	traceline(spot, spot - '32 0 0', TRUE, world);
	d2 = 32 * trace_fraction;
	if (d1 + d2 < 32)
		return FALSE;
	if (d1 < 16)
		spot_x = spot_x - (16 - d1);
	else if (d2 < 16)
		spot_x = spot_x + (16 - d2);

	// y
	traceline(spot, spot + '0 32 0', TRUE, world);
	d1 = 32 * trace_fraction;
	traceline(spot, spot - '0 32 0', TRUE, world);
	d2 = 32 * trace_fraction;
	if (d1 + d2 < 32)
		return FALSE;
	if (d1 < 16)
		spot_y = spot_y - (16 - d1);
	else if (d2 < 16)
		spot_y = spot_y + (16 - d2);

	// z
	traceline(spot, spot + '0 0 56', TRUE, world);
	d1 = 56 * trace_fraction;
	traceline(spot, spot - '0 0 56', TRUE, world);
	d2 = 56 * trace_fraction;
	if (d1 + d2 < 56)
		return FALSE;
	if (d1 < 32)
		spot_z = spot_z - (32 - d1);
	else if (d2 < 24)
		spot_z = spot_z + (24 - d2);

	setorigin(self, spot);
	return TRUE;
};

//
//  F L Y  T H R O U G H  O B S T A C L E
//
void () observer_fly_through_obstacle =
{
	local float i, spots;
	local vector spot, inc;

	spot = self.origin + '0 0 22';
	traceline(spot, spot + 48 * v_forward, TRUE, self);
	if (trace_fraction == 1)
	{
		self.attack_finished = time;
		return;
	}
	else if (time < self.attack_finished + 0.2)
		return;

	inc = 32 * v_forward;
	spot = spot + 100 * v_forward;
	i = 0;
	spots = 0;
	while (i < 6)
	{
		local float c;
		c = pointcontents(spot);
		if ((c != CONTENT_SOLID) && (c != CONTENT_SKY))
		{
			spots = spots + 1;
			if (spots > 1)
			{
				if (observer_set_origin(spot - 16 * v_forward))
					return;
			}
		}
		else
			spots = 0;
		spot = spot + inc;
		i = i + 1;
	}
};

//
//  F L Y  M O V E
//
//  Called every frame for observers in Fly mode.
//
void () observer_fly_move = 
{
	local float z;

	if (self.button2)
		z = 200;
	else
		z = self.cl[CL_CMD_UP];

    makevectors(self.v_angle);
	self.velocity = v_forward * self.cl[CL_CMD_FORWARD] + v_right * self.cl[CL_CMD_SIDE];
	self.velocity_z = self.velocity_z + z;
	z = vlen(self.velocity);
	if (z > 500)
		self.velocity = self.velocity * (500 / z);

	if (self.button0)
		observer_fly_through_obstacle();
	else
		self.attack_finished = time;
};

//
//  P R E  T H I N K
//
//  Called from PlayerPreThink in client.qc
//
void () observer_pre_think =
{
    local float jump;

    // Deal with button2.  jump is set to TRUE is button2 was just pressed,
    // FALSE otherwise.
    if (self.button2)
    {
        if (self.flags & FL_JUMPRELEASED)
        {
            jump = TRUE;
            self.flags = self.flags - FL_JUMPRELEASED;
        }
        else
            jump = FALSE;
    }
    else
    {
        jump = FALSE;
        self.flags = self.flags | FL_JUMPRELEASED;
    }

    if (self.oflags & (OBSERVER_CHASE | OBSERVER_DEMO | OBSERVER_CAMERA))
    {
        if (jump)
		{
			if (self.movetarget.classname == "player")
			{
				if (self.button0)
					observer_prev_target();
				else
					observer_next_target();
			}
			else
			{
    			if (self.button0)
    				observer_prev_camera();
    			else
    				observer_next_camera();
			}
			self.crmod_cam_delay = time + 6;
		}
    }
    else
    {
        if (self.oflags & OBSERVER_WALK && !self.button0)
        {
            if (self.waterlevel == 2)
                CheckWaterJump ();
    
            if (self.button2)
                observer_jump(jump);
    
            self.finaldest_y = self.movetype = MOVETYPE_WALK;
        }
        else
        {
			self.waterlevel = 0;
            observer_fly_move();
            self.flags = self.flags | FL_ONGROUND;
            self.finaldest_y = self.movetype = MOVETYPE_FLY;
        }
        observer_check_teleport();

		// check for player in sight every frame
		observer_get_target();
    }
};

//
//  P O S T  T H I N K
//
//  Called from PlayerPostThink in Client.qc
//
void () observer_post_think =
{
	if (!gameover)
	{
		if (self.oflags & OBSERVER_CHASE)
			observer_set_chase_position();
		else if (self.oflags & OBSERVER_DEMO)
			observer_set_demo_position();
		else if (self.oflags & OBSERVER_CAMERA)
    		observer_set_camera_position();
    		
		// When an observer touches a door they are not teleported through
		// the door immediately as this doesn't seem to work.  Instead, the
		// POP_FORWARD flag is set and they are teleported through the next
		// time observer_post_think is called.
		//
		if (self.style & ELOHIM_POP_FORWARD)
		{
			self.style = self.style - ELOHIM_POP_FORWARD;
			setorigin(self, self.dest);
			self.velocity = self.dest1;
		}

		// CRMOD - this was moved here, so the observers.health could be
		//         compared to movetarget's in tourney and auto modes
		//         to see if movetarget was damaged
        
		// Update the status bar every frame
		observer_update_status_bar();

		// Update the heads up display every 0.5 seconds
		//if (time > self.delay)
		//	display_update();
	}

    if (self.impulse)
    {
		self.finaldest_x = time; // player is alive
		// Redirect impulses 1-10 when player is entering a number
		if (self.use != SUB_Null)
		{
			if (self.impulse >= 1 && self.impulse <= 10)
			{
				if (self.impulse == 10)
					self.impulse = 230;
				else
					self.impulse = self.impulse + 230;
			}
		}
        if ((self.impulse >= 20) && (self.impulse <= 250))
            elohim_impulse ();
    }
};

//
//  D O O R  T O U C H
//
//  Called from door_touch in Doors.qc.  When an observer in walk or
//  fly mode touches a door, their POP_FORWARD flag is set when it is
//  possible to teleport them through the door.  The global variable
//  'other' points to the player that touched the door.
//
void () observer_door_touch =
{
    local float temp;
    local string stemp;

    // Ignore observers that are in chase mode or who are above the door
    if (other.origin_z > self.absmax_z || self.oflags & (OBSERVER_CHASE | OBSERVER_DEMO))
        return;

    temp = utils_min(self.size_x, self.size_y) + 40;
    other.dest1 = other.dest = other.velocity;
    other.dest_z = 0;
    other.dest = other.dest * (temp / vlen(other.dest));
    other.dest = other.origin + other.dest;
    if (pointcontents(other.dest) != CONTENT_SOLID)
        other.style = other.style | ELOHIM_POP_FORWARD;
};

//
//  H E A D S  U P
//
//  Enable/disable heads up display.
//
void () observer_heads_up =
{
    if (self.style & ELOHIM_HEADS_UP)
    {
        self.style = self.style - ELOHIM_HEADS_UP;
        sprint(self, "Heads up display disabled\n");
        stuffcmd(self, "viewsize 100\n");
    }
    else
    {
        self.style = self.style | ELOHIM_HEADS_UP;
        sprint(self, "Heads up display enabled\n");
        stuffcmd(self, "viewsize 120\n");
    }
    self.delay = 0;
};

